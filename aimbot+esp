if not game:IsLoaded() then game.Loaded:Wait() end

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

-- Configuration
local Config = {
    ESP = {
        Enabled     = true,
        TeamCheck   = false,
        ShowOutline = true,
        ShowLines   = true,
        Rainbow     = false,
        FillColor   = Color3.fromRGB(255,255,255),
        OutlineColor= Color3.fromRGB(255,255,255),
        TextColor   = Color3.fromRGB(255,255,255),
        LineColor   = Color3.fromRGB(255,255,255),
        FillTransparency    = 0.5,
        OutlineTransparency = 0,
        Font        = Enum.Font.SciFi,
        TeamColor   = Color3.fromRGB(0,255,0),
        EnemyColor  = Color3.fromRGB(255,0,0),
        ToggleKey   = Enum.KeyCode.RightBracket,
    },
    Aimbot = {
        Enabled         = false,
        TeamCheck       = true,
        VisibilityCheck = true,
        FOV             = 150,
        ToggleKey       = Enum.KeyCode.F,
        FOVColor        = Color3.fromRGB(255,128,128),
        FOVRainbow      = false,
    },
    MenuCollapsed = false,
}

local FlyConfig = {
    Enabled = false,
    Speed = 1,
    ToggleKey = Enum.KeyCode.H,
}

-- ðŸ› ï¸ ÐžÐ±Ð½Ð¾Ð²Ð»Ñ‘Ð½Ð½Ð°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¿Ð¾Ð»Ñ‘Ñ‚Ð°
local tpwalking = false
local vertical = 0

local function setPlatformState(enabled)
    local hum = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    for _, state in ipairs(Enum.HumanoidStateType:GetEnumItems()) do
        pcall(function()
            hum:SetStateEnabled(state, enabled)
        end)
    end
end

local function startFly()
    local plr = Players.LocalPlayer
    local char = plr.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    tpwalking = true
    setPlatformState(false)
    hum.PlatformStand = true
    char.Animate.Disabled = true
    for _, track in pairs(hum:GetPlayingAnimationTracks()) do track:AdjustSpeed(0) end

    local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
    local bg = Instance.new("BodyGyro", torso)
    bg.P = 9e4
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.CFrame = torso.CFrame

    local bv = Instance.new("BodyVelocity", torso)
    bv.Velocity = Vector3.new(0, 0.1, 0)
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    local ctrl = {f = 0, b = 0, l = 0, r = 0, u = 0, d = 0}

    local inputDown = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.W then ctrl.f = 1
        elseif input.KeyCode == Enum.KeyCode.S then ctrl.b = -1
        elseif input.KeyCode == Enum.KeyCode.A then ctrl.l = -1
        elseif input.KeyCode == Enum.KeyCode.D then ctrl.r = 1
        elseif input.KeyCode == Enum.KeyCode.Space then ctrl.u = 1
        elseif input.KeyCode == Enum.KeyCode.LeftControl then ctrl.d = -1 end
    end)

    local inputUp = UserInputService.InputEnded:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.W then ctrl.f = 0
        elseif input.KeyCode == Enum.KeyCode.S then ctrl.b = 0
        elseif input.KeyCode == Enum.KeyCode.A then ctrl.l = 0
        elseif input.KeyCode == Enum.KeyCode.D then ctrl.r = 0
        elseif input.KeyCode == Enum.KeyCode.Space then ctrl.u = 0
        elseif input.KeyCode == Enum.KeyCode.LeftControl then ctrl.d = 0 end
    end)

    RunService.RenderStepped:Connect(function()
        if not tpwalking then
            inputDown:Disconnect()
            inputUp:Disconnect()
            bg:Destroy()
            bv:Destroy()
            if char:FindFirstChild("Humanoid") then
                char.Humanoid.PlatformStand = false
                char.Animate.Disabled = false
            end
            return
        end
        local cam = workspace.CurrentCamera
        local move = (cam.CFrame.lookVector * (ctrl.f + ctrl.b)) + (cam.CFrame.RightVector * (ctrl.r + ctrl.l)) + (Vector3.new(0, ctrl.u + ctrl.d, 0))
        bv.Velocity = move.Unit * (FlyConfig.Speed * 10)
        bg.CFrame = cam.CFrame * CFrame.Angles(-math.rad((ctrl.f + ctrl.b) * 50), 0, 0)
    end)
end

local function stopFly()
    tpwalking = false

    local char = Players.LocalPlayer.Character
    if char and char:FindFirstChildOfClass("Humanoid") then
        char.Humanoid.PlatformStand = false
        char.Animate.Disabled = false
    end

    -- Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ BodyVelocity Ð¸ BodyGyro Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ
    local torso = char and (char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso"))
    if torso then
        for _, obj in ipairs(torso:GetChildren()) do
            if obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") then
                obj:Destroy()
            end
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == FlyConfig.ToggleKey then
        FlyConfig.Enabled = not FlyConfig.Enabled
        if FlyConfig.Enabled then startFly() else stopFly() end
    end
end)

-- State
local ESPs, Lines = {}, {}
local FOVCircle

local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2
FOVCircle.NumSides = 100
FOVCircle.Filled = false
FOVCircle.Visible = false

-- Utils
local function getName(p)
    return p.Name
end
local function getHealth(p)
    local h = p.Character and p.Character:FindFirstChild("Humanoid")
    return (h and h.Health>0) and math.floor(h.Health) or 0
end
local function isAlive(p) return getHealth(p)>0 end
local function getRainbow() return Color3.fromHSV((tick()%5)/5,1,1) end
local function getESPColor(p)
    if Config.ESP.Rainbow then return getRainbow() end
    if Config.ESP.TeamCheck then return (p.TeamColor==Players.LocalPlayer.TeamColor) and Config.ESP.TeamColor or Config.ESP.EnemyColor end
    return Config.ESP.FillColor
end
local function getOutlineColor(p)
    if Config.ESP.Rainbow then return getRainbow() end
    if Config.ESP.TeamCheck then return (p.TeamColor==Players.LocalPlayer.TeamColor) and Config.ESP.TeamColor or Config.ESP.EnemyColor end
    return Config.ESP.OutlineColor
end
local function rayVisible(p)
    if not Config.Aimbot.VisibilityCheck then return true end
    local cam=workspace.CurrentCamera
    local head=p.Character and p.Character:FindFirstChild("Head") if not head then return false end
    local rp=RaycastParams.new()
    rp.FilterType=Enum.RaycastFilterType.Blacklist
    rp.FilterDescendantsInstances={Players.LocalPlayer.Character,p.Character}
    return not workspace:Raycast(cam.CFrame.Position, head.Position-cam.CFrame.Position, rp)
end

-- ESP handlers
local function createOrUpdateESP(p)
    if not ESPs[p] then
        local hl=Instance.new("Highlight"); hl.Adornee=p.Character; hl.DepthMode=Enum.HighlightDepthMode.AlwaysOnTop; hl.Parent=p.Character
        local bg=Instance.new("BillboardGui",p.Character); bg.AlwaysOnTop=true; bg.Size=UDim2.new(0,200,0,30); bg.StudsOffset=Vector3.new(0,2,0)
        local tl=Instance.new("TextLabel",bg); tl.Size=UDim2.new(1,0,1,0); tl.BackgroundTransparency=1; tl.Font=Config.ESP.Font; tl.TextSize=18
        ESPs[p]={hl=hl,bg=bg,tl=tl}
    end
    local d=ESPs[p]
    d.hl.FillColor=getESPColor(p); d.hl.FillTransparency=Config.ESP.FillTransparency
    d.hl.OutlineColor=getOutlineColor(p); d.hl.OutlineTransparency=Config.ESP.ShowOutline and Config.ESP.OutlineTransparency or 1
    d.tl.TextColor3=Config.ESP.TextColor
    d.tl.Text=string.format("%s | HP:%d | %dm",getName(p),getHealth(p),math.floor((Players.LocalPlayer.Character.HumanoidRootPart.Position-p.Character.HumanoidRootPart.Position).Magnitude))
end
local function removeESP(p)
    if ESPs[p] then ESPs[p].hl:Destroy(); ESPs[p].bg:Destroy(); ESPs[p]=nil end
    if Lines[p] then Lines[p]:Remove(); Lines[p]=nil end
end

-- Clean up on player leaving
Players.PlayerRemoving:Connect(function(player)
    if ESPs[player] then
        ESPs[player].hl:Destroy()
        ESPs[player].bg:Destroy()
        ESPs[player] = nil
    end
    if Lines[player] then
        Lines[player]:Remove()
        Lines[player] = nil
    end
end)

local function getClosestTarget()
    local cam = workspace.CurrentCamera
    local closest, minDist = nil, Config.Aimbot.FOV

    for _, p in ipairs(Players:GetPlayers()) do
        if p == Players.LocalPlayer then continue end
        if Config.Aimbot.TeamCheck and p.Team == Players.LocalPlayer.Team then continue end
        if not isAlive(p) then continue end
        if Config.Aimbot.VisibilityCheck and not rayVisible(p) then continue end

        local head = p.Character and p.Character:FindFirstChild("Head")
        if not head then continue end
        local screenPos, onScreen = cam:WorldToViewportPoint(head.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2)).Magnitude
        if dist < minDist then
            closest = head
            minDist = dist
        end
    end
    return closest
end

-- Render loop: only alive players on server
RunService.RenderStepped:Connect(function()
    local cam = workspace.CurrentCamera
    for _, player in ipairs(Players:GetPlayers()) do
        local char = player.Character
        local hum = char and char:FindFirstChild("Humanoid")
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if player ~= Players.LocalPlayer and hum and hum.Health > 0 and root then
            if Config.ESP.Enabled then
                createOrUpdateESP(player)
                if Config.ESP.ShowLines then
                    if not Lines[player] then
                        local ln = Drawing.new("Line")
                        ln.Thickness    = 2
                        ln.Transparency = 1
                        Lines[player]   = ln
                    end
                    local pos, onScreen = cam:WorldToViewportPoint(root.Position)
                    Lines[player].Visible = onScreen
                    if onScreen then
                        Lines[player].From  = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y)
                        Lines[player].To    = Vector2.new(pos.X, pos.Y)
                        Lines[player].Color = getESPColor(player)
                    end
                elseif Lines[player] then
                    Lines[player].Visible = false
                end
            else
                removeESP(player)
            end
        else
            removeESP(player)
        end
    end

    -- Aimbot
if Config.Aimbot.Enabled then
    local target = getClosestTarget()
    if target then
        local cam = workspace.CurrentCamera
        cam.CFrame = CFrame.lookAt(cam.CFrame.Position, target.Position)
    end
end

-- FOV Circle update
local cam = workspace.CurrentCamera
FOVCircle.Visible = Config.Aimbot.Enabled
FOVCircle.Position = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2)
FOVCircle.Color = Config.Aimbot.FOVRainbow and getRainbow() or Config.Aimbot.FOVColor
FOVCircle.Radius = Config.Aimbot.FOV


    -- Aimbot logic unchanged below...
end)

-- Hotkeys binding
UserInputService.InputBegan:Connect(function(inp, gp)
    if gp then return end
    if inp.UserInputType == Enum.UserInputType.Keyboard then
        if inp.KeyCode == Config.ESP.ToggleKey then
            Config.ESP.Enabled = not Config.ESP.Enabled
            print("ESP toggled:", Config.ESP.Enabled)
        elseif inp.KeyCode == Config.Aimbot.ToggleKey then
            Config.Aimbot.Enabled = not Config.Aimbot.Enabled
            print("Aimbot toggled:", Config.Aimbot.Enabled)
        end
    end
end)

-- GUI Setup 
local screenGui = Instance.new("ScreenGui", CoreGui)
screenGui.Name = "SslkinGui"
screenGui.ResetOnSpawn = false

local frame = Instance.new("Frame", screenGui)
frame.Name = "MainFrame"
frame.Position = UDim2.new(0, 20, 0.5, -200)
frame.Size = UDim2.new(0, 300, 0, 0)
frame.AutomaticSize = Enum.AutomaticSize.Y
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

local titleBar = Instance.new("Frame", frame)
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)

local titleText = Instance.new("TextLabel", titleBar)
titleText.Name = "TitleText"
titleText.Size = UDim2.new(1, -40, 1, 0)
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "SSLKIN ESP + AIMBOT"
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 14
titleText.TextColor3 = Color3.new(1, 1, 1)
titleText.TextXAlignment = Enum.TextXAlignment.Left

local collapseBtn = Instance.new("TextButton", titleBar)
collapseBtn.Name = "Collapse"
collapseBtn.Size = UDim2.new(0, 26, 0, 26)
collapseBtn.Position = UDim2.new(1, -30, 0.5, -13)
collapseBtn.Text = "âˆ’"
collapseBtn.Font = Enum.Font.GothamBold
collapseBtn.TextSize = 18
collapseBtn.TextColor3 = Color3.new(1, 1, 1)
collapseBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
Instance.new("UICorner", collapseBtn).CornerRadius = UDim.new(0, 6)

local scroll = Instance.new("ScrollingFrame", frame)
scroll.Position = UDim2.new(0, 0, 0, 30)
scroll.Size = UDim2.new(1, 0, 1, -46)
scroll.CanvasSize = UDim2.new(0, 0, 3, 0)
scroll.ScrollBarThickness = 6
scroll.BackgroundTransparency = 1
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.ClipsDescendants = true

local innerContainer = Instance.new("Frame", scroll)
innerContainer.Name = "InnerContainer"
innerContainer.BackgroundTransparency = 1
innerContainer.Size = UDim2.new(1, -20, 0, 0)
innerContainer.Position = UDim2.new(0, 10, 0, 0)
innerContainer.AutomaticSize = Enum.AutomaticSize.Y
innerContainer.ClipsDescendants = false

local UIListLayout = Instance.new("UIListLayout", innerContainer)
UIListLayout.Padding = UDim.new(0, 6)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

local function toggleMenu()
    Config.MenuCollapsed = not Config.MenuCollapsed
    local collapsed = Config.MenuCollapsed
    local size = collapsed and UDim2.new(0, 280, 0, 40) or UDim2.new(0, 280, 0, 800)
    local text = collapsed and "+" or "âˆ’"
    local color = collapsed and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)

    TweenService:Create(frame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = size
    }):Play()

    TweenService:Create(collapseBtn, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        BackgroundColor3 = color
    }):Play()

    collapseBtn.Text = text
    scroll.Visible = not collapsed
end

collapseBtn.MouseButton1Click:Connect(toggleMenu)

UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == Enum.KeyCode.Insert then
        toggleMenu()
    end
end)

local UIListLayout = Instance.new("UIListLayout", scroll)
UIListLayout.Padding = UDim.new(0, 6)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

-- Helper functions
local function sectionHeader(text)
	local lbl = Instance.new("TextLabel", scroll)
	lbl.Text = text
	lbl.Size = UDim2.new(1, -10, 0, 24)
	lbl.Font = Enum.Font.GothamBold
	lbl.TextSize = 16
	lbl.TextColor3 = Color3.fromRGB(255,255,255)
	lbl.BackgroundTransparency = 1
end

local function toggle(label, default, callback)
	local btn = Instance.new("TextButton", scroll)
	btn.Size = UDim2.new(1, -10, 0, 28)
	btn.Text = label .. ": " .. (default and "ON" or "OFF")
	btn.Font = Enum.Font.Gotham
	btn.TextSize = 14
	btn.TextColor3 = Color3.new(1,1,1)
	btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
	btn.AutoButtonColor = false
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

	btn.MouseButton1Click:Connect(function()
		default = not default
		btn.Text = label .. ": " .. (default and "ON" or "OFF")
		callback(default)
	end)
end

local function slider(label, min, max, value, callback)
	local container = Instance.new("Frame", scroll)
	container.Size = UDim2.new(1, -10, 0, 36)
	container.BackgroundTransparency = 1

	local lbl = Instance.new("TextLabel", container)
	lbl.Text = label .. ": " .. value
	lbl.Size = UDim2.new(1, 0, 0.5, 0)
	lbl.Font = Enum.Font.Gotham
	lbl.TextSize = 13
	lbl.TextColor3 = Color3.new(1,1,1)
	lbl.BackgroundTransparency = 1

	local sliderBack = Instance.new("Frame", container)
	sliderBack.Position = UDim2.new(0,0,0.5,4)
	sliderBack.Size = UDim2.new(1, 0, 0, 6)
	sliderBack.BackgroundColor3 = Color3.fromRGB(50,50,50)
	Instance.new("UICorner", sliderBack).CornerRadius = UDim.new(1,0)

	local sliderFill = Instance.new("Frame", sliderBack)
	sliderFill.Size = UDim2.new((value - min) / (max - min), 0, 1, 0)
	sliderFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(1,0)

	local dragging = false
	sliderBack.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)
	RunService.RenderStepped:Connect(function()
		if dragging then
			local pos = UserInputService:GetMouseLocation().X
			local abs = sliderBack.AbsolutePosition.X
			local width = sliderBack.AbsoluteSize.X
			local pct = math.clamp((pos - abs) / width, 0, 1)
			local newVal = math.floor((min + (max - min) * pct) * 10) / 10
			sliderFill.Size = UDim2.new(pct, 0, 1, 0)
			lbl.Text = label .. ": " .. newVal
			callback(newVal)
		end
	end)
end

local function colorPicker(labelText, currentColor, callback)
    local lbl = Instance.new("TextLabel", scroll)
    lbl.Text = labelText
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.BackgroundTransparency = 1
    lbl.Size = UDim2.new(1, -10, 0, 20)
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14

    local colors = {
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(255, 0, 0),
        Color3.fromRGB(0, 255, 0),
        Color3.fromRGB(0, 0, 255),
        Color3.fromRGB(255, 255, 0),
        Color3.fromRGB(255, 0, 255),
        Color3.fromRGB(0, 255, 255),
        Color3.fromRGB(128, 128, 128),
        Color3.fromRGB(255, 165, 0),
    }

    local row = Instance.new("Frame", scroll)
    row.Size = UDim2.new(1, -10, 0, 28)
    row.BackgroundTransparency = 1

    local layout = Instance.new("UIListLayout", row)
    layout.FillDirection = Enum.FillDirection.Horizontal
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    layout.Padding = UDim.new(0, 4)

    for _, clr in pairs(colors) do
        local btn = Instance.new("TextButton", row)
        btn.Size = UDim2.new(0, 24, 0, 24)
        btn.BackgroundColor3 = clr
        btn.Text = ""
        btn.AutoButtonColor = false
        btn.MouseButton1Click:Connect(function()
            callback(clr)
        end)
    end
end

-- ðŸ”¥ Ð“Ð¾Ñ€ÑÑ‡Ð¸Ðµ ÐºÐ»Ð°Ð²Ð¸ÑˆÐ¸ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ ESP / Aimbot
local function keyBindButton(name, currentKey, callback)
    local btn = Instance.new("TextButton", scroll)
    btn.Size = UDim2.new(1, -10, 0, 24)
    btn.Text = name .. " Hotkey: [" .. tostring(currentKey.Name) .. "]"
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 13
    btn.AutoButtonColor = false
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

    btn.MouseButton1Click:Connect(function()
        btn.Text = name .. " Hotkey: [Press any key]"
        local conn
        conn = UserInputService.InputBegan:Connect(function(input, gp)
            if not gp and input.UserInputType == Enum.UserInputType.Keyboard then
                conn:Disconnect()
                callback(input.KeyCode)
                btn.Text = name .. " Hotkey: [" .. tostring(input.KeyCode.Name) .. "]"
            end
        end)
    end)
end

-- ÐšÐ½Ð¾Ð¿ÐºÐ¸ Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð³Ð¾Ñ€ÑÑ‡Ð¸Ñ… ÐºÐ»Ð°Ð²Ð¸Ñˆ
keyBindButton("ESP", Config.ESP.ToggleKey, function(newKey)
    Config.ESP.ToggleKey = newKey
end)

keyBindButton("Aimbot", Config.Aimbot.ToggleKey, function(newKey)
    Config.Aimbot.ToggleKey = newKey
end)

-- ðŸŸ¦ ESP
sectionHeader("ðŸ”·ESP Settings")
toggle("ESP", Config.ESP.Enabled, function(v) Config.ESP.Enabled = v end)
toggle("Team Check", Config.ESP.TeamCheck, function(v) Config.ESP.TeamCheck = v end)
toggle("Show Outline", Config.ESP.ShowOutline, function(v) Config.ESP.ShowOutline = v end)
toggle("Show Lines", Config.ESP.ShowLines, function(v) Config.ESP.ShowLines = v end)
toggle("Rainbow Colors", Config.ESP.Rainbow, function(v) Config.ESP.Rainbow = v end)

colorPicker("Fill Color", Config.ESP.FillColor, function(c) Config.ESP.FillColor = c end)
colorPicker("Outline Color", Config.ESP.OutlineColor, function(c) Config.ESP.OutlineColor = c end)
colorPicker("Text Color", Config.ESP.TextColor, function(c) Config.ESP.TextColor = c end)
slider("Fill Transparency", 0, 1, Config.ESP.FillTransparency, function(v) Config.ESP.FillTransparency = v end)
slider("Outline Transparency", 0, 1, Config.ESP.OutlineTransparency, function(v) Config.ESP.OutlineTransparency = v end)

-- ðŸŸ¥ Aimbot
sectionHeader("ðŸ”·Aimbot Settings")
toggle("Aimbot", Config.Aimbot.Enabled, function(v) Config.Aimbot.Enabled = v end)
toggle("Team Check", Config.Aimbot.TeamCheck, function(v) Config.Aimbot.TeamCheck = v end)
toggle("Visibility Check", Config.Aimbot.VisibilityCheck, function(v) Config.Aimbot.VisibilityCheck = v end)
slider("FOV Radius", 10, 500, Config.Aimbot.FOV, function(v) Config.Aimbot.FOV = v end)
toggle("FOV Rainbow", Config.Aimbot.FOVRainbow, function(v) Config.Aimbot.FOVRainbow = v end)
colorPicker("Aimbot FOV Color", Config.Aimbot.FOVColor, function(c) Config.Aimbot.FOVColor = c end)

-- ðŸŸ¨ Fly System Integration

-- ÐŸÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð´Ð»Ñ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ
local FlyConfig = {
    Enabled = false,
    Speed = 1,
    ToggleKey = Enum.KeyCode.H,
}
local tpwalking = false

local function setPlatformState(enabled)
    local hum = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    for _, state in ipairs(Enum.HumanoidStateType:GetEnumItems()) do
        pcall(function()
            hum:SetStateEnabled(state, enabled)
        end)
    end
end

local function startFly()
    local speaker = Players.LocalPlayer
    local chr = speaker.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
    if not hum then return end

    tpwalking = true
    setPlatformState(false)
    chr.Animate.Disabled = true
    for _, track in pairs(hum:GetPlayingAnimationTracks()) do
        track:AdjustSpeed(0)
    end

    spawn(function()
        local hb = RunService.Heartbeat
        while tpwalking and chr and hum and hum.Parent and hum.Health > 0 do
            hb:Wait()
            if hum.MoveDirection.Magnitude > 0 then
                chr:TranslateBy(hum.MoveDirection)
            end
        end
    end)

    local torso = chr:FindFirstChild("Torso") or chr:FindFirstChild("UpperTorso")
    local bg = Instance.new("BodyGyro", torso)
    bg.P = 9e4
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.CFrame = torso.CFrame

    local bv = Instance.new("BodyVelocity", torso)
    bv.Velocity = Vector3.new(0, 0.1, 0)
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    local ctrl = {f = 0, b = 0, l = 0, r = 0}
    local lastctrl = {f = 0, b = 0, l = 0, r = 0}
    local speed = 0
    local maxspeed = 50

    local uisConn = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local k = input.KeyCode
            if k == Enum.KeyCode.W then ctrl.f = FlyConfig.Speed
            elseif k == Enum.KeyCode.S then ctrl.b = -FlyConfig.Speed
            elseif k == Enum.KeyCode.A then ctrl.l = -FlyConfig.Speed
            elseif k == Enum.KeyCode.D then ctrl.r = FlyConfig.Speed end
        end
    end)
    local uisConn2 = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local k = input.KeyCode
            if k == Enum.KeyCode.W then ctrl.f = 0
            elseif k == Enum.KeyCode.S then ctrl.b = 0
            elseif k == Enum.KeyCode.A then ctrl.l = 0
            elseif k == Enum.KeyCode.D then ctrl.r = 0 end
        end
    end)

    local rsConn = RunService.RenderStepped:Connect(function()
        if not tpwalking or not chr or not chr:FindFirstChild("Humanoid") then
            uisConn:Disconnect()
            uisConn2:Disconnect()
            rsConn:Disconnect()
            bg:Destroy()
            bv:Destroy()
            setPlatformState(true)
            chr.Animate.Disabled = false
            return
        end

        if ctrl.f + ctrl.b ~= 0 or ctrl.l + ctrl.r ~= 0 then
            speed += 0.5 + (speed / maxspeed)
            if speed > maxspeed then speed = maxspeed end
        else
            speed -= 1
            if speed < 0 then speed = 0 end
        end

        if speed ~= 0 then
            bv.Velocity = ((workspace.CurrentCamera.CFrame.lookVector * (ctrl.f + ctrl.b)) +
                ((workspace.CurrentCamera.CFrame * CFrame.new(ctrl.l + ctrl.r, (ctrl.f + ctrl.b) * 0.2, 0)).Position - workspace.CurrentCamera.CFrame.Position)) * speed
        else
            bv.Velocity = Vector3.zero
        end

        bg.CFrame = workspace.CurrentCamera.CFrame * CFrame.Angles(-math.rad((ctrl.f + ctrl.b) * 50 * speed / maxspeed), 0, 0)
    end)
end

local function stopFly()
    tpwalking = false
end

-- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ñ ÐºÐ»Ð°Ð²Ð¸ÑˆÐ¸
UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == FlyConfig.ToggleKey then
        FlyConfig.Enabled = not FlyConfig.Enabled
        if FlyConfig.Enabled then
            startFly()
        else
            stopFly()
        end
        print("Fly toggled:", FlyConfig.Enabled)
    end
end)

-- GUI: Fly
sectionHeader("ðŸŸ¨ Fly Settings")

toggle("Fly", FlyConfig.Enabled, function(v)
    FlyConfig.Enabled = v
    if v then startFly() else stopFly() end
end)

keyBindButton("Fly", FlyConfig.ToggleKey, function(newKey)
    FlyConfig.ToggleKey = newKey
end)

slider("Fly Speed", 1, 10, FlyConfig.Speed, function(v)
    FlyConfig.Speed = math.floor(v)
end)
